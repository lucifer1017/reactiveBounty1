{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-b33a6df357982ccbaf1a68ce902600427be67c26",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/ReactiveMirror.sol": "project/contracts/ReactiveMirror.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/IReactive.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.20;\r\n\r\n/**\r\n * @title IPayer\r\n * @notice Interface for contracts that need to pay Reactive Network callback fees\r\n */\r\ninterface IPayer {\r\n    function pay() external payable;\r\n}\r\n\r\n/**\r\n * @title IReactive\r\n * @notice Interface for Reactive Network contracts that react to cross-chain events\r\n * @dev According to Reactive Network docs: \"interface IReactive is IPayer\"\r\n */\r\ninterface IReactive is IPayer {\r\n    /**\r\n     * @notice Log record structure representing an event from a source chain\r\n     * @dev Must match the Reactive Network specification exactly\r\n     */\r\n    struct LogRecord {\r\n        uint256 chain_id;\r\n        address _contract;\r\n        uint256 topic_0;\r\n        uint256 topic_1;\r\n        uint256 topic_2;\r\n        uint256 topic_3;\r\n        bytes data;\r\n        uint256 block_number;\r\n        uint256 op_code;\r\n        uint256 block_hash;\r\n        uint256 tx_hash;\r\n        uint256 log_index;\r\n    }\r\n\r\n    event Callback(\r\n        uint256 indexed chain_id,\r\n        address indexed _contract,\r\n        uint64 indexed gas_limit,\r\n        bytes payload\r\n    );\r\n\r\n    function react(LogRecord calldata log) external;\r\n}\r\n\r\n/**\r\n * @title ISystemContract\r\n * @notice Interface for the Reactive Network System Contract\r\n */\r\ninterface ISystemContract {\r\n    function subscribe(\r\n        uint256 chain_id,\r\n        address contract_address,\r\n        uint256 topic_0,\r\n        uint256 topic_1,\r\n        uint256 topic_2,\r\n        uint256 topic_3\r\n    ) external;\r\n\r\n    function unsubscribe(\r\n        uint256 chain_id,\r\n        address contract_address,\r\n        uint256 topic_0,\r\n        uint256 topic_1,\r\n        uint256 topic_2,\r\n        uint256 topic_3\r\n    ) external;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n"
      },
      "project/contracts/ReactiveMirror.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./IReactive.sol\";\n\ncontract ReactiveMirror is IReactive {\n    address public constant SYSTEM_CONTRACT = 0x0000000000000000000000000000000000fffFfF;\n    uint256 public constant REACTIVE_IGNORE = 0xa65f96fc951c35ead38878e0f0b7a3c744a6f5ccc1476b313353ce31712313ad;\n\n    // --- CONFIGURATION ---\n    // Origin: Polygon Amoy (ID: 80002)\n    uint256 public constant ORIGIN_CHAIN_ID = 80002;\n    // UPDATE THIS CONSTANT AFTER DEPLOYING MOCKFEED ON AMOY:\n    address public immutable originFeed; \n\n    // Destination: Sepolia (ID: 11155111)\n    uint256 public constant DEST_CHAIN_ID = 11155111;\n    // Destination Contract (FeedProxy on Sepolia)\n    address public immutable destContract;\n\n    // Topic 0: AnswerUpdated(int256,uint256,uint256)\n    uint256 public constant TOPIC_0 = 0x0559884fd3a460db3073b7fc896cc77986f16e378210ded43186175bf646fc5f;\n    bytes32 public constant DOMAIN_SEPARATOR = keccak256(\"REACTIVE_ORACLE_V1\");\n    uint64 public constant CALLBACK_GAS_LIMIT = 500000;\n\n    // VM detection - matches reference pattern\n    bool private vm;\n    \n    function _detectVm() private view returns (bool) {\n        uint256 size;\n        assembly { \n            size := extcodesize(SYSTEM_CONTRACT) \n        }\n        return size == 0;\n    }\n\n    constructor(address _originFeed, address _destContract, address _systemContract) {\n        require(_originFeed != address(0), \"Invalid origin feed\");\n        require(_destContract != address(0), \"Invalid dest contract\");\n        \n        originFeed = _originFeed;\n        destContract = _destContract;\n        \n        address systemContract = _systemContract == address(0) ? SYSTEM_CONTRACT : _systemContract;\n        vm = _detectVm();\n\n        // Subscribe only on Reactive Network main instance (not in ReactVM)\n        if (!vm) {\n            try ISystemContract(systemContract).subscribe(\n                ORIGIN_CHAIN_ID,\n                originFeed,\n                TOPIC_0,\n                REACTIVE_IGNORE, \n                REACTIVE_IGNORE, \n                REACTIVE_IGNORE \n            ) {} catch {}\n        }\n    }\n\n    // Debug events to track execution flow\n    event DebugStep(string step, uint256 value1, uint256 value2);\n    event DebugData(bytes data, uint256 length);\n    event DebugDecodeSuccess(int256 answer, uint256 roundId, uint256 updatedAt);\n    event DebugDecodeFailed();\n    event DebugCallbackEmitted(uint256 chainId, address destContract, uint64 gasLimit);\n\n    function react(LogRecord calldata log) external override {\n        // CRITICAL: Match reference implementation pattern exactly\n        // VM check - react() should only run in ReactVM\n        require(vm, \"ReactiveMirror: VM only\");\n        \n        // Validate source first\n        require(log.chain_id == ORIGIN_CHAIN_ID, \"ReactiveMirror: wrong chain\");\n        require(log._contract == originFeed, \"ReactiveMirror: wrong feed\");\n        require(log.topic_0 == TOPIC_0, \"ReactiveMirror: wrong event\");\n        \n        // Decode AnswerUpdated event\n        // Reference pattern: answer and roundId from topics, updatedAt from data\n        // But if topics are 0x0, decode all from data\n        int256 answer;\n        uint256 roundId;\n        uint256 updatedAt;\n        \n        if (log.topic_1 != 0 && log.topic_2 != 0) {\n            // Indexed parameters in topics (reference pattern)\n            answer = int256(log.topic_1);\n            roundId = log.topic_2;\n            require(log.data.length >= 32, \"ReactiveMirror: insufficient data\");\n            updatedAt = abi.decode(log.data, (uint256));\n        } else {\n            // All non-indexed - decode all from data\n            require(log.data.length >= 96, \"ReactiveMirror: insufficient data\");\n            (answer, roundId, updatedAt) = abi.decode(log.data, (int256, uint256, uint256));\n        }\n\n        // Encode Payload - match reference pattern exactly\n        bytes memory payload = abi.encodeWithSignature(\n            \"updatePrice(address,bytes32,uint80,int256,uint256,uint256,uint80)\",\n            address(0), // Will be replaced with rvm_id by Reactive Network\n            DOMAIN_SEPARATOR,\n            uint80(roundId), \n            answer, \n            updatedAt, // startedAt\n            updatedAt, // updatedAt\n            uint80(roundId) // answeredInRound\n        );\n\n        // Emit Callback - Reactive Network picks this up\n        emit Callback(DEST_CHAIN_ID, destContract, CALLBACK_GAS_LIMIT, payload);\n    }\n    \n    // Helper function for decoding (must be external for try-catch)\n    function decodeEventData(bytes calldata data) external pure returns (int256, uint256, uint256) {\n        return abi.decode(data, (int256, uint256, uint256));\n    }\n    \n    // Helper function for decoding single value (updatedAt from data)\n    function decodeSingleValue(bytes calldata data) external pure returns (uint256) {\n        return abi.decode(data, (uint256));\n    }\n\n    /**\n     * @notice Pay function required by IPayer interface\n     * @dev Allows System Contract to settle callback debt automatically\n     * @dev Called by System Contract (0x0000000000000000000000000000000000fffFfF) when callback results in debt\n     * @dev This enables \"On-The-Spot Payment\" for reactive contracts\n     * @dev The System Contract sends funds via this function to settle debt\n     */\n    function pay() external payable override {\n        require(msg.sender == SYSTEM_CONTRACT, \"ReactiveMirror: not System Contract\");\n        // Accept payment from System Contract\n        // The System Contract will send funds to settle any outstanding debt\n        // This function just needs to accept the payment\n    }\n\n    /**\n     * @notice Receive function to accept native REACT tokens\n     * @dev Allows direct funding of the contract for callback execution\n     */\n    receive() external payable {}\n}"
      }
    }
  }
}